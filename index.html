<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Poll</title>
    <script src="https://cdn.tailwindcss.com"></script>
  </head>
  <body
    class="font-sans flex items-start flex-wrap text-center gap-3 pt-12 bg-gray-900 text-green-500"
  >
    <!-- Vote counter and log box (fixed left) -->
    <div class="w-full max-w-sm flex flex-col gap-2 z-50">
      <!-- Votes sent counter -->
      <!-- Start Voting button -->
      <div class="flex gap-4 justify-center mb-4">
        <!-- Will Button -->
        <div>
          <button
            id="voteWill"
            class="px-4 py-2 bg-green-800 border-2 border-green-500 text-green-300 rounded-md font-mono transition-colors duration-200 hover:bg-green-500 hover:text-black"
          >
            Start Voting for Will
          </button>

          <div
            id="voteCounterWill"
            class="text-green-400 font-bold font-mono text-sm"
          >
            üó≥Ô∏è Will Votes: 0
          </div>
        </div>
        <div>
          <!-- Emilio Button -->
          <button
            id="voteEmilio"
            class="px-4 py-2 bg-blue-800 border-2 border-blue-500 text-blue-300 rounded-md font-mono transition-colors duration-200 hover:bg-blue-500 hover:text-black"
          >
            Start Voting for Emilio
          </button>

          <div
            id="voteCounterEmilio"
            class="text-blue-300 font-bold font-mono text-sm"
          >
            üó≥Ô∏è Emilio Votes: 0
          </div>
        </div>
      </div>

<!-- Log box -->
<div
  id="logBox"
  class="w-full h-96 overflow-y-auto text-left bg-pink-50 text-pink-700 font-mono text-xs p-3 rounded-md border border-pink-200"
>
  üìú Log initialized...<br />
</div>

    <!-- Container for voting -->
    <div
      id="votingContainer"
      class="flex flex-col items-start gap-3 h-[1000px]"
    >
      <!-- Poll wrapper -->
      <div
        id="pollWrapper"
        class="w-full min-h-[100px] bg-gray-800 p-3 rounded-lg shadow-md shadow-green-500/50"
      >
        <script
          type="text/javascript"
          charset="utf-8"
          src="https://secure.polldaddy.com/p/15909793.js"
        ></script>
      </div>
    </div>

    <script>
      let successfulVotesForWill = 0;
      let successfulVotesForEmilio = 0;
      let isVoting = false;
      let selectedCandidateId = null; // will hold the radio button ID

      // Cache DOM elements to avoid repeated queries
      const logBox = document.getElementById("logBox");
      // Cache the vote counter DOM elements
      const voteCounterWill = document.getElementById("voteCounterWill");
      const voteCounterEmilio = document.getElementById("voteCounterEmilio");

      // Custom logger: append messages and auto-trim to last 20
      function log(msg) {
        const time = new Date().toLocaleTimeString();
        const logBox = document.getElementById("logBox");

        // Check if message mentions rate limit
        const isRateLimit = /rate limit/i.test(msg);
        const color = isRateLimit ? "red" : "green";

        // Append the message
        logBox.innerHTML += `<span style="color:${color}">[${time}] ${msg}</span><br>`;
        logBox.scrollTop = logBox.scrollHeight; // auto-scroll

        // Keep only last 20 messages
        const lines = logBox.innerHTML.split("<br>");
        if (lines.length > 21) {
          lines.splice(0, lines.length - 21);
          logBox.innerHTML = lines.join("<br>");
        }
      }

      // Update vote counter in DOM

      function updateVoteCounter(candidate) {
        if (candidate === "Will") {
          voteCounterWill.innerText = `üó≥Ô∏è Total Votes Sent for Will: ${successfulVotesForWill}`;
        } else if (candidate === "Emilio") {
          voteCounterEmilio.innerText = `üó≥Ô∏è Total Votes Sent for Emilio: ${successfulVotesForEmilio}`;
        }
      }
      // Wait for an element to appear with retries
      const wait = (ms) => new Promise((r) => setTimeout(r, ms));
      const randomDelay = (min, max) => Math.random() * (max - min) + min;
      async function waitForElement(selector, attempts = 20, delay = 100) {
        for (let i = 0; i < attempts; i++) {
          const el = document.querySelector(selector);
          if (el) return el;
          await wait(delay);
        }
        return null;
      }

      // Handle captcha, rate limit, and voting logic
      async function postVoteHandler() {
        const captchaInput = await waitForElement("#answer_15909793");
        if (captchaInput) {
          log("üßÆ Captcha input found. Solving...");
          const captchaQuestion = document.querySelector(".h-captcha p");
          const voteBtn = document.querySelector("#pd-vote-button15909793");

          if (captchaQuestion) {
            const expr = (captchaQuestion.innerText.match(/[\d+\-*/ ]+/) || [
              "",
            ])[0]
              .replace("=", "")
              .trim();
            if (expr) {
              const answer = Function("return(" + expr + ")")();
              captchaInput.value = answer;
              captchaInput.dispatchEvent(new Event("input", { bubbles: true }));
              log(`üßÆ Captcha solved: ${expr} = ${answer}`);
              await wait(randomDelay(500, 1000));

              // In postVoteHandler, after voteBtn.click():
              if (voteBtn && !voteBtn.disabled) {
                voteBtn.click();

                // Increment counter based on selected candidate
                if (selectedCandidateId === "PDI_answer70048651") {
                  successfulVotesForWill++;
                  updateVoteCounter("Will");
                } else if (selectedCandidateId === "PDI_answer70048652") {
                  successfulVotesForEmilio++;
                  updateVoteCounter("Emilio");
                }

                log(
                  `üó≥Ô∏è Vote sent for ${selectedCandidateId === "PDI_answer70048651" ? "Will" : "Emilio"}!`,
                );
              }
            }
          }

          const returnLinkAfterCaptcha =
            await waitForElement("a.pds-return-poll");
          if (returnLinkAfterCaptcha) {
            log("üîó Return link detected after captcha, clicking...");
            await wait(randomDelay(100, 500));
            returnLinkAfterCaptcha.click();
          }
          return;
        }

        // Rate limit case
        const returnLink = document.querySelector("a.pds-return-poll");
        if (returnLink) {
          log("‚ö†Ô∏è Rate limit detected. Pausing 60-70s...");
          await wait(randomDelay(60000, 63000));
          log("üîÑ Resuming vote after pause.");
          returnLink.click();
        }
      }

      // Main voting loop
      async function startVotingLoop(candidateId) {
        isVoting = true;
        selectedCandidateId = candidateId;
        log(
          `üöÄ Starting the poll automation script for candidate ${candidateId}...`,
        );

        while (isVoting) {
          try {
            const returnLink = await waitForElement(
              "a.pds-return-poll",
              1,
              200,
            );
            if (returnLink) {
              log("Found 'Return to Poll' link. Handling rate limit.");
              await postVoteHandler();
              continue;
            }

            // Wait for the candidate's radio button and vote button
            const radioBtn = await waitForElement(`input#${candidateId}`);
            const voteBtn = document.querySelector("#pd-vote-button15909793");

            if (radioBtn && voteBtn && !voteBtn.disabled) {
              if (!radioBtn.checked) {
                log(`üîò ${candidateId} not checked. Clicking it now.`);
                radioBtn.click();
              } else {
                log(`‚úÖ ${candidateId} already checked.`);
              }

              await wait(randomDelay(500, 1000));
              voteBtn.click();
              log("üó≥Ô∏è Initial vote button clicked.");
              await postVoteHandler();
            } else {
              log("‚ö†Ô∏è No votable elements found. Resetting the poll...");

              // Remove old poll wrapper
              const oldPoll = document.getElementById("pollWrapper");
              if (oldPoll) oldPoll.remove();

              // Recreate poll container & wrapper
              const votingContainer =
                document.getElementById("votingContainer");
              if (votingContainer) {
                const pollWrapper = document.createElement("div");
                pollWrapper.id = "pollWrapper";
                pollWrapper.className =
                  "w-full min-h-[100px] bg-gray-800 p-3 rounded-lg shadow-md shadow-green-500/50";

                const script = document.createElement("script");
                script.type = "text/javascript";
                script.charset = "utf-8";
                script.src = "https://secure.polldaddy.com/p/15909793.js";

                pollWrapper.appendChild(script);
                votingContainer.appendChild(pollWrapper);
              }

              // Optional: wait a short random delay before next iteration
              await wait(randomDelay(1000, 2000));
              log("‚ôªÔ∏è Poll reset, continuing loop...");
            }

            await wait(randomDelay(500, 1000));
          } catch (err) {
            log("üí• Error in loop, restarting in 5 seconds.");
            console.error(err);
            await wait(5000);
          }
        }
      }

      // Hook both buttons
      document.getElementById("voteWill").addEventListener("click", () => {
        if (!isVoting) startVotingLoop("PDI_answer70048651");
        else log("‚ö†Ô∏è Voting already in progress.");
      });

      document.getElementById("voteEmilio").addEventListener("click", () => {
        if (!isVoting) startVotingLoop("PDI_answer70048652");
        else log("‚ö†Ô∏è Voting already in progress.");
      });
    </script>
  </body>
</html>
